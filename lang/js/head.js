// Generated by CoffeeScript 1.6.3
var CSEcho, CSIf, CSOperate_add, CSOperate_dotRef, CSOperate_dynamicRef, CSOperate_forceHDFRef, CSOperate_forceNumber, CSOperate_isEqual, CSValue, CSVar, Dataset, HDF, HDFPath, HdfGet, HdfRef, HdfSet, ToHDF, fs, hdfString, json, outputBuffers, _CSValue;

fs = require("fs");

HDFPath = process.argv[2];

if (!HDFPath) {
  console.log("need an hdf path");
  process.exit(0);
}

hdfString = fs.readFileSync(HDFPath).toString();

json = exports.hdfToJson(hdfString);

outputBuffers = [];

_CSValue = (function() {
  function _CSValue(value, type) {
    if (!type) {
      type = "None";
    }
    this.type = type;
    this.value = value;
  }

  _CSValue.prototype.toPrimitive = function() {
    if (this.type === "number" || this.type === "string") {
      return this.value || 0;
    }
    if (this.type === "hdfQuery") {
      if (!this.hdfNode || "") {
        this.hdfNode = Dataset.get(this.value);
      }
      return this.hdfNode.____value.toPrimitive() || "";
    }
    if (this.type === "None") {
      return "";
    }
    throw new Error("Unknow value type");
  };

  return _CSValue;

})();

CSValue = function(v, t) {
  return new _CSValue(v, t);
};

HDF = (function() {
  function HDF(json) {
    this.data = json;
    this.regulize(this.data);
  }

  HDF.prototype.regulize = function(json) {
    var item, _results;
    if (typeof json.____value !== "undefined" && !json.____value.type) {
      json.____value = CSValue(json.____value, "string");
    }
    _results = [];
    for (item in json) {
      if (item === "____value") {
        continue;
      }
      if (typeof json[item] === "string" || typeof json[item] === "number") {
        _results.push(json[item] = {
          ____value: CSValue(json[item], "string")
        });
      } else {
        _results.push(this.regulize(json[item]));
      }
    }
    return _results;
  };

  HDF.prototype.get = function(path, root) {
    var cur, pathes, route;
    if (!path) {
      throw new Error("get empty hdf");
    }
    pathes = path.split(".");
    if (!root) {
      cur = this.data;
    } else {
      cur = root;
    }
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    return cur;
  };

  HDF.prototype.set = function(path, value) {
    var cur, pathes, route;
    if (!path) {
      throw new Error("get empty hdf");
    }
    pathes = path.split(".");
    cur = this.data;
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    cur.____value = value;
    return cur;
  };

  HDF.prototype.getNode = function(path) {
    var cur, item, nodes, pathes, route;
    if (!path) {
      throw Error("get empty hdf");
    }
    pathes = path.split(".");
    cur = this.data;
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    nodes = [];
    for (item in cur) {
      if (item !== "____value") {
        if (!cur[item].____value) {
          cur[item].____value = new _CSValue();
        }
        nodes.push(cur[item]);
      }
    }
    return {
      nodes: nodes,
      ____value: cur.____value || CSValue("", "string")
    };
  };

  return HDF;

})();

Dataset = new HDF(json);

CSVar = function(value) {
  return outputBuffers.push(value.toPrimitive().toString());
};

CSEcho = function(string) {
  return outputBuffers.push(string);
};

CSIf = function(v) {
  if (v === true) {
    return true;
  }
  if (v === false) {
    return false;
  }
  if (v && v.value) {
    return true;
  }
  return false;
};

HdfSet = function(path, value) {
  if (typeof value.toPrimitive === "function") {
    return Dataset.set(path, value);
  }
};

HdfGet = function(path) {
  return Dataset.get(path);
};

HdfRef = function(ref, node) {
  return Dataset.data[ref] = node;
};

ToHDF = function(v) {
  var node;
  console.assert(v.type === "hdfQuery");
  return node = Dataset.getNode(v.value);
};

CSOperate_dynamicRef = function(v1, v2) {
  var hdfNode, path, v3;
  console.assert(v1.type === "hdfQuery");
  path = v2.toPrimitive();
  if (!v1.hdfNode) {
    v1.hdfNode = Dataset.get(v1.value);
  }
  hdfNode = Dataset.get(path, v1.hdfNode);
  v3 = CSValue(v1.value + "." + path, "hdfQuery");
  v3.hdfNode = hdfNode;
  return v3;
};

CSOperate_dotRef = function(v1, v2) {
  var e, hdfNode, path, v3;
  try {
    console.assert(v1.type === "hdfQuery");
    console.assert(v2.type === "hdfQuery");
  } catch (_error) {
    e = _error;
    throw new Error("Invalid DotRef");
  }
  path = v2.value;
  if (!v1.hdfNode) {
    v1.hdfNode = Dataset.get(v1.value);
  }
  hdfNode = Dataset.get(path, v1.hdfNode);
  v3 = CSValue(v1.value + "." + path, "hdfQuery");
  v3.hdfNode = hdfNode;
  return v3;
};

CSOperate_forceNumber = function(v) {
  if (v.type === "number") {
    return v;
  } else {
    return CSValue(parseInt(v.value) || 0, "number");
  }
};

CSOperate_add = function(v1, v2) {
  var result;
  if (!v2) {
    return v1;
  }
  result = (v1.toPrimitive() + v2.toPrimitive()) || "";
  if (typeof result === "number") {
    return CSValue(result, "number");
  } else {
    return CSValue(result.toString(), "string");
  }
};

CSOperate_isEqual = function(v1, v2) {
  return v1.toPrimitive().toString() === v2.toPrimitive().toString();
};

CSOperate_forceHDFRef = function(v) {
  return v;
};
