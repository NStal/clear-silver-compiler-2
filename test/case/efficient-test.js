// Generated by CoffeeScript 1.6.3
var InitHDFReader;

InitHDFReader = function() {
  var hdfToJson, parseHDFDict, reg;
  reg = {};
  reg.space = /\s/i;
  reg.hdfQuery = /[a-z0-9_.]/i;
  parseHDFDict = function(string, start, hdfDict, current) {
    var index, queryStart, subQuery, value, valueEnd, valueStart;
    index = start;
    while (true) {
      while (reg.space.test(string[index])) {
        index++;
      }
      if (!string[index] || string[index] === "}") {
        return index;
      }
      queryStart = index;
      while (reg.hdfQuery.test(string[index])) {
        index++;
      }
      if (!string[index]) {
        throw new Error("Unexpect HDF End");
      }
      subQuery = string.substring(queryStart, index);
      while (new RegExp(" ", "i").test(string[index])) {
        index++;
      }
      if (string[index] === "=") {
        index++;
        while (new RegExp(" ", "i").test(string[index])) {
          index++;
        }
        valueStart = index;
        valueEnd = string.indexOf("\n", index);
        value = string.substring(valueStart, valueEnd);
        index = valueEnd + 1;
        hdfDict.push({
          path: [current, subQuery].join("."),
          value: value
        });
        continue;
      } else if (string[index] === "{") {
        index++;
        index = parseHDFDict(string, index + 1, hdfDict, [current, subQuery].join("."));
        if (string[index] !== "}") {
          throw new Error("unclosed {");
        }
        index++;
        continue;
      } else if (string[index] === ":") {
        while (new RegExp(" ", "i").test(string[index])) {
          index++;
        }
        valueStart = index;
        valueEnd = string.indexOf("\n", index);
        value = string.substring(valueStart, valueEnd);
        index = valueEnd + 1;
        hdfDict.push({
          path: [current, subQuery].join("."),
          value: value.trim(),
          refer: true
        });
        continue;
      } else {
        throw new Error("Unexpect Token at index " + index + ":" + string[index]);
      }
    }
  };
  hdfToJson = function(string) {
    var dict, item, json, route, routes, _i, _j, _len, _len1, _refer;
    dict = [];
    parseHDFDict(string, 0, dict, "root");
    json = {};
    for (_i = 0, _len = dict.length; _i < _len; _i++) {
      item = dict[_i];
      routes = item.path.split(".");
      _refer = json;
      for (_j = 0, _len1 = routes.length; _j < _len1; _j++) {
        route = routes[_j];
        if (route.indexOf("____") === 0) {
          console.warn("hdf query path can't start with ____");
          return null;
        }
        if (!_refer[route]) {
          _refer[route] = {};
        }
        _refer = _refer[route];
      }
      if (item.refer) {
        console.warn("current not support refering");
        continue;
      }
      _refer.____value = item.value;
    }
    return json.root;
  };
  if (exports) {
    exports.parseHDFDict = parseHDFDict;
    return exports.hdfToJson = hdfToJson;
  }
};

InitHDFReader();

// Generated by CoffeeScript 1.6.3
var CSEcho, CSIf, CSOperate_add, CSOperate_dotRef, CSOperate_dynamicRef, CSOperate_forceHDFRef, CSOperate_forceNumber, CSOperate_isEqual, CSValue, CSVar, Dataset, HDF, HDFPath, HdfGet, HdfRef, HdfSet, ToHDF, fs, hdfString, json, outputBuffers, _CSValue;

fs = require("fs");

HDFPath = process.argv[2];

if (!HDFPath) {
  console.log("need an hdf path");
  process.exit(0);
}

hdfString = fs.readFileSync(HDFPath).toString();

json = exports.hdfToJson(hdfString);

outputBuffers = [];

_CSValue = (function() {
  function _CSValue(value, type) {
    if (!type) {
      type = "None";
    }
    this.type = type;
    this.value = value;
  }

  _CSValue.prototype.toPrimitive = function() {
    if (this.type === "number" || this.type === "string") {
      return this.value || 0;
    }
    if (this.type === "hdfQuery") {
      if (!this.hdfNode || "") {
        this.hdfNode = Dataset.get(this.value);
      }
      return this.hdfNode.____value.toPrimitive() || "";
    }
    if (this.type === "None") {
      return "";
    }
    throw new Error("Unknow value type");
  };

  return _CSValue;

})();

CSValue = function(v, t) {
  return new _CSValue(v, t);
};

HDF = (function() {
  function HDF(json) {
    this.data = json;
    this.regulize(this.data);
  }

  HDF.prototype.regulize = function(json) {
    var item, _results;
    if (typeof json.____value !== "undefined" && !json.____value.type) {
      json.____value = CSValue(json.____value, "string");
    }
    _results = [];
    for (item in json) {
      if (item === "____value") {
        continue;
      }
      if (typeof json[item] === "string" || typeof json[item] === "number") {
        _results.push(json[item] = {
          ____value: CSValue(json[item], "string")
        });
      } else {
        _results.push(this.regulize(json[item]));
      }
    }
    return _results;
  };

  HDF.prototype.get = function(path, root) {
    var cur, pathes, route;
    if (!path) {
      throw new Error("get empty hdf");
    }
    pathes = path.split(".");
    if (!root) {
      cur = this.data;
    } else {
      cur = root;
    }
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    return cur;
  };

  HDF.prototype.set = function(path, value) {
    var cur, pathes, route;
    if (!path) {
      throw new Error("get empty hdf");
    }
    pathes = path.split(".");
    cur = this.data;
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    cur.____value = value;
    return cur;
  };

  HDF.prototype.getNode = function(path) {
    var cur, item, nodes, pathes, route;
    if (!path) {
      throw Error("get empty hdf");
    }
    pathes = path.split(".");
    cur = this.data;
    while (pathes.length > 0) {
      route = pathes.shift();
      if (!cur[route]) {
        cur[route] = {};
      }
      if (!cur[route].____value) {
        cur[route].____value = new _CSValue();
      }
      cur = cur[route];
    }
    nodes = [];
    for (item in cur) {
      if (item !== "____value") {
        if (!cur[item].____value) {
          cur[item].____value = new _CSValue();
        }
        nodes.push(cur[item]);
      }
    }
    return {
      nodes: nodes,
      ____value: cur.____value || CSValue("", "string")
    };
  };

  return HDF;

})();

Dataset = new HDF(json);

CSVar = function(value) {
  return outputBuffers.push(value.toPrimitive().toString());
};

CSEcho = function(string) {
  return outputBuffers.push(string);
};

CSIf = function(v) {
  if (v === true) {
    return true;
  }
  if (v === false) {
    return false;
  }
  if (v && v.value) {
    return true;
  }
  return false;
};

HdfSet = function(path, value) {
  if (typeof value.toPrimitive === "function") {
    return Dataset.set(path, value);
  }
};

HdfGet = function(path) {
  return Dataset.get(path);
};

HdfRef = function(ref, node) {
  return Dataset.data[ref] = node;
};

ToHDF = function(v) {
  var node;
  console.assert(v.type === "hdfQuery");
  return node = Dataset.getNode(v.value);
};

CSOperate_dynamicRef = function(v1, v2) {
  var hdfNode, path, v3;
  console.assert(v1.type === "hdfQuery");
  path = v2.toPrimitive();
  if (!v1.hdfNode) {
    v1.hdfNode = Dataset.get(v1.value);
  }
  hdfNode = Dataset.get(path, v1.hdfNode);
  v3 = CSValue(v1.value + "." + path, "hdfQuery");
  v3.hdfNode = hdfNode;
  return v3;
};

CSOperate_dotRef = function(v1, v2) {
  var e, hdfNode, path, v3;
  try {
    console.assert(v1.type === "hdfQuery");
    console.assert(v2.type === "hdfQuery");
  } catch (_error) {
    e = _error;
    throw new Error("Invalid DotRef");
  }
  path = v2.value;
  if (!v1.hdfNode) {
    v1.hdfNode = Dataset.get(v1.value);
  }
  hdfNode = Dataset.get(path, v1.hdfNode);
  v3 = CSValue(v1.value + "." + path, "hdfQuery");
  v3.hdfNode = hdfNode;
  return v3;
};

CSOperate_forceNumber = function(v) {
  if (v.type === "number") {
    return v;
  } else {
    return CSValue(parseInt(v.value) || 0, "number");
  }
};

CSOperate_add = function(v1, v2) {
  var result;
  if (!v2) {
    return v1;
  }
  result = (v1.toPrimitive() + v2.toPrimitive()) || "";
  if (typeof result === "number") {
    return CSValue(result, "number");
  } else {
    return CSValue(result.toString(), "string");
  }
};

CSOperate_isEqual = function(v1, v2) {
  return v1.toPrimitive().toString() === v2.toPrimitive().toString();
};

CSOperate_forceHDFRef = function(v) {
  return v;
};

function main(){

CSEcho('');
CSEcho('\n\n');
//call-expand Date._weekday
var __CSVar_0=CSValue('Foo','hdfQuery');
CSEcho('\n');
var __CSVar_1=CSValue('Days','hdfQuery');
var refer = __CSVar_1;
refer = ToHDF(refer)
for(var index=0;index<refer.nodes.length;index++){
    HdfRef('wday',refer.nodes[index]);
    CSEcho('\n  ');
(function(){
    var __CSVar_3=CSValue('wday','hdfQuery');
var __CSVar_4=CSValue('Foo','hdfQuery');
var __CSVar_2=CSOperate_isEqual(__CSVar_3,__CSVar_4);
    if(CSIf(__CSVar_2)){
        CSEcho('\n    ');
var __CSVar_6=CSValue('wday','hdfQuery');
var __CSVar_7=CSValue('Abbr','hdfQuery');
var __CSVar_5=CSOperate_dotRef(__CSVar_6,__CSVar_7);
CSVar(__CSVar_5);
CSEcho('\n  ');
        return;
    }
    
    
})()
CSEcho('\n');
    
}
CSEcho('\n');
(function(){
    var __CSVar_9=CSValue('Foo','hdfQuery');
var __CSVar_10=CSValue('6','string');
var __CSVar_8=CSOperate_isEqual(__CSVar_9,__CSVar_10);
    if(CSIf(__CSVar_8)){
        CSEcho('\n');
var __CSVar_13=CSValue('Days','hdfQuery');
var __CSVar_14=CSValue('0','hdfQuery');
var __CSVar_12=CSOperate_dotRef(__CSVar_13,__CSVar_14);
var __CSVar_15=CSValue('Abbr','hdfQuery');
var __CSVar_11=CSOperate_dotRef(__CSVar_12,__CSVar_15);
CSVar(__CSVar_11);
CSEcho('\n');
        return;
    }
    var __CSVar_17=CSValue('Foo','hdfQuery');
var __CSVar_18=CSValue('0','string');
var __CSVar_16=CSOperate_isEqual(__CSVar_17,__CSVar_18);
if(__CSVar_16){
    CSEcho('\n');
var __CSVar_21=CSValue('Days','hdfQuery');
var __CSVar_22=CSValue('1','hdfQuery');
var __CSVar_20=CSOperate_dotRef(__CSVar_21,__CSVar_22);
var __CSVar_23=CSValue('Abbr','hdfQuery');
var __CSVar_19=CSOperate_dotRef(__CSVar_20,__CSVar_23);
CSVar(__CSVar_19);
CSEcho('\n');
    return;
}

var __CSVar_25=CSValue('Foo','hdfQuery');
var __CSVar_26=CSValue('1','string');
var __CSVar_24=CSOperate_isEqual(__CSVar_25,__CSVar_26);
if(__CSVar_24){
    CSEcho('\n');
var __CSVar_29=CSValue('Days','hdfQuery');
var __CSVar_30=CSValue('2','hdfQuery');
var __CSVar_28=CSOperate_dotRef(__CSVar_29,__CSVar_30);
var __CSVar_31=CSValue('Abbr','hdfQuery');
var __CSVar_27=CSOperate_dotRef(__CSVar_28,__CSVar_31);
CSVar(__CSVar_27);
CSEcho('\n');
    return;
}

var __CSVar_33=CSValue('Foo','hdfQuery');
var __CSVar_34=CSValue('2','string');
var __CSVar_32=CSOperate_isEqual(__CSVar_33,__CSVar_34);
if(__CSVar_32){
    CSEcho('\n');
var __CSVar_37=CSValue('Days','hdfQuery');
var __CSVar_38=CSValue('3','hdfQuery');
var __CSVar_36=CSOperate_dotRef(__CSVar_37,__CSVar_38);
var __CSVar_39=CSValue('Abbr','hdfQuery');
var __CSVar_35=CSOperate_dotRef(__CSVar_36,__CSVar_39);
CSVar(__CSVar_35);
CSEcho('\n');
    return;
}

var __CSVar_41=CSValue('Foo','hdfQuery');
var __CSVar_42=CSValue('3','string');
var __CSVar_40=CSOperate_isEqual(__CSVar_41,__CSVar_42);
if(__CSVar_40){
    CSEcho('\n');
var __CSVar_45=CSValue('Days','hdfQuery');
var __CSVar_46=CSValue('4','hdfQuery');
var __CSVar_44=CSOperate_dotRef(__CSVar_45,__CSVar_46);
var __CSVar_47=CSValue('Abbr','hdfQuery');
var __CSVar_43=CSOperate_dotRef(__CSVar_44,__CSVar_47);
CSVar(__CSVar_43);
CSEcho('\n');
    return;
}

var __CSVar_49=CSValue('Foo','hdfQuery');
var __CSVar_50=CSValue('4','string');
var __CSVar_48=CSOperate_isEqual(__CSVar_49,__CSVar_50);
if(__CSVar_48){
    CSEcho('\n');
var __CSVar_53=CSValue('Days','hdfQuery');
var __CSVar_54=CSValue('5','hdfQuery');
var __CSVar_52=CSOperate_dotRef(__CSVar_53,__CSVar_54);
var __CSVar_55=CSValue('Abbr','hdfQuery');
var __CSVar_51=CSOperate_dotRef(__CSVar_52,__CSVar_55);
CSVar(__CSVar_51);
CSEcho('\n');
    return;
}

var __CSVar_57=CSValue('Foo','hdfQuery');
var __CSVar_58=CSValue('5','string');
var __CSVar_56=CSOperate_isEqual(__CSVar_57,__CSVar_58);
if(__CSVar_56){
    CSEcho('\n');
var __CSVar_61=CSValue('Days','hdfQuery');
var __CSVar_62=CSValue('6','hdfQuery');
var __CSVar_60=CSOperate_dotRef(__CSVar_61,__CSVar_62);
var __CSVar_63=CSValue('Abbr','hdfQuery');
var __CSVar_59=CSOperate_dotRef(__CSVar_60,__CSVar_63);
CSVar(__CSVar_59);
CSEcho('\n');
    return;
}

    
})()
CSEcho('\n');
CSEcho('\n');
};

// Generated by CoffeeScript 1.6.3
var count, end, start, _, _i;

start = Date.now();

count = 10 * 1000;

for (_ = _i = 0; 0 <= count ? _i <= count : _i >= count; _ = 0 <= count ? ++_i : --_i) {
  outputBuffers.length = 0;
  main();
  HDF.call(Dataset, json);
  outputBuffers.join("");
}

end = Date.now();

console.log(end - start, "ms");

console.log(count, "task ,", (end - start) / count, "per task");

console.log("result", outputBuffers.join(""));
