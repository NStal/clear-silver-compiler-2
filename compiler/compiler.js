// Generated by CoffeeScript 1.6.3
(function() {
  var Context, Flatten, OperateNameMap, Templates, fillTemplate, fs, printMiddleCode, translate, translateExpression;

  fs = require("fs");

  Flatten = require("./flatten.coffee");

  Context = (function() {
    function Context() {
      this.variableIndex = 0;
      this.variableIdMapTable = [];
      this.defineTables = [];
    }

    Context.prototype.getVariableName = function(id, hint) {
      hint = hint || "_";
      if (this.variableIdMapTable[id]) {
        return this.variableIdMapTable[id];
      }
      this.variableIdMapTable[id] = "__CSVar" + hint + id;
      return this.variableIdMapTable[id];
    };

    return Context;

  })();

  Templates = {
    "if": "{precalculate}\nif(CSIf({expression0})){\n    {body}\n}else{\n    {elseBody}\n}",
    each: "var refer = HdfRef('{hdf}');\nfor(var index=0;index<refer.nodes.length;index++){\n    HdfSet('{name}',refer.nodes[index]);\n    {body}\n}",
    "var": "{precalculate}\nCSVar({expression0});",
    "set": "{precalculate}\nHdfSet('{expression0}',{expression1});",
    echo: "CSEcho('{validString}');",
    "call-expand": "//call-expand {name}"
  };

  exports.Context = Context;

  exports.assamble = function(ACTree, context) {
    var codes, node, _i, _len;
    codes = [];
    for (_i = 0, _len = ACTree.length; _i < _len; _i++) {
      node = ACTree[_i];
      codes.push(translate(node, context));
    }
    return codes.join("\n");
  };

  OperateNameMap = {
    "+": "add",
    "-": "minus",
    "*": "multiply",
    "/": "divide",
    "%": "mod",
    ".": "dotRef",
    "[": "dynamicRef"
  };

  translateExpression = function(flattendExpression, context) {
    var action, item, operateName, params, results, tVarName, _i, _len;
    results = [];
    for (_i = 0, _len = flattendExpression.length; _i < _len; _i++) {
      action = flattendExpression[_i];
      tVarName = context.getVariableName(action.id);
      if (action.type === "init") {
        results.push(["var ", tVarName, "=", "CSValue(\'", action.value.content, "\');"].join(""));
        continue;
      } else if (action.type === "functionEval") {
        params = ((function() {
          var _j, _len1, _ref, _results;
          _ref = action.params;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            item = _ref[_j];
            _results.push(context.getVariableName(item));
          }
          return _results;
        })()).join(",");
        results.push(["var ", context.getVariableName(action.id), "=", action.functionName + "(", params, ");"].join(""));
        continue;
      } else if (action.type === "operator") {
        console.assert(OperatorNameMap[action.operater], "Should be an known operater");
        operateName = OperatorNameMap[action.operater];
        params = ((function() {
          var _j, _len1, _ref, _results;
          _ref = action.params;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            item = _ref[_j];
            _results.push(context.getVariableName(item));
          }
          return _results;
        })()).join(",");
        results.push(["var ", context.getVariableName(action.id), "=", "CSOperate_" + operateName + "(", params, ");"]);
        continue;
      }
      throw new Error("Unexpect flattend expression " + action.type);
    }
    return results.join("\n");
  };

  translate = function(node, context) {
    var body, bodyCode, child, code, elseBody, elseBodyCode, exp, expressions, hdf, item, name, precalculate, precalculateCode, template, validString, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    if (node.expressions) {
      node.flattendExpressions = [];
      _ref = node.expressions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        node.flattendExpressions.push(Flatten.flatten(item));
      }
    }
    template = Templates[node.type];
    if (!template) {
      throw new Error("Missing template:" + node.type);
    }
    body = [];
    console.log(node.body.length);
    _ref1 = node.body;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      child = _ref1[_j];
      body.push(translate(child, context));
    }
    bodyCode = body.join("\n");
    elseBody = [];
    if (node.elseNode) {
      _ref2 = node.elseNode.body;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        child = _ref2[_k];
        elseBody.push(translate(child, context));
      }
    }
    elseBodyCode = elseBody.join("\n");
    precalculate = [];
    expressions = [];
    _ref3 = node.flattendExpression;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      exp = _ref3[_l];
      precalculate.push(translateExpression(exp.actions, context));
      expressions.push(context.getVariableName(exp.finalValue.id));
    }
    precalculateCode = precalculate.join("\n");
    name = node.names && node.names[0] || null;
    hdf = node.hdfRefs && node.hdfRefs[0] || null;
    if (typeof node.validString === "string") {
      validString = node.validString;
    } else {
      validString = null;
    }
    code = fillTemplate(template, {
      body: bodyCode,
      expression: expressions,
      precalculate: precalculateCode,
      name: name,
      hdf: hdf,
      validString: validString,
      elseBody: elseBodyCode
    });
    return code;
  };

  fillTemplate = function(format, data) {
    var index, item, itemOfArr, replacements, safeIndex, safeWord, _i, _j, _k, _len, _len1, _len2, _ref;
    replacements = [];
    safeWord = parseInt(Math.random() * 10000000000000).toString() + parseInt(Math.random() * 10000000000000).toString();
    safeIndex = 0;
    for (item in data) {
      if (data[item] instanceof Array) {
        _ref = data[item];
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          itemOfArr = _ref[index];
          console.assert(typeof itemOfArr === "string", data, "fillTemplate only accept objects consist of string and Array of string");
          console.error("!!!ARR", item, index);
          if ((format.indexOf("{" + item + index + "}")) >= 0) {
            replacements.push({
              holder: "{" + item + index + "}",
              content: itemOfArr.toString(),
              safeWord: safeWord + (safeIndex++)
            });
          }
        }
      } else if (typeof data[item] === "string" || data[item] === null) {
        if ((format.indexOf("{" + item + "}")) >= 0) {
          replacements.push({
            holder: "{" + item + "}",
            content: data[item],
            safeWord: safeWord + (safeIndex++)
          });
        }
      } else {
        throw new Error("fillTemplate only accept objects consist of string and Array of string");
      }
    }
    for (_j = 0, _len1 = replacements.length; _j < _len1; _j++) {
      item = replacements[_j];
      format = format.replace(new RegExp(item.holder, "g"), item.safeWord);
    }
    for (_k = 0, _len2 = replacements.length; _k < _len2; _k++) {
      item = replacements[_k];
      if (item.content === null) {
        throw new Error("expect " + item.holder + " but has null");
      }
      format = format.replace(new RegExp(item.safeWord, "g"), item.content);
    }
    return format;
  };

  printMiddleCode = function(tree, indent) {
    var createIndent, exp, expStrings, flattend, index, item, node, string, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
    indent = indent || 0;
    createIndent = function(count) {
      var item;
      return ((function() {
        var _i, _results;
        _results = [];
        for (item = _i = 0; 0 <= count ? _i <= count : _i >= count; item = 0 <= count ? ++_i : --_i) {
          _results.push("  ");
        }
        return _results;
      })()).join("");
    };
    string = createIndent(indent) + "|";
    _results = [];
    for (_i = 0, _len = tree.length; _i < _len; _i++) {
      node = tree[_i];
      if (node.expressions) {
        _ref = node.expressions;
        for (index = _j = 0, _len1 = _ref.length; _j < _len1; index = ++_j) {
          exp = _ref[index];
          flattend = Flatten.flatten(exp);
          expStrings = [];
          _ref1 = flattend.actions;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            item = _ref1[_k];
            expStrings.push(JSON.stringify(item));
          }
          expStrings.push("Finally" + JSON.stringify(flattend.finalValue));
          console.log(string, "exp:", index, expStrings.join("\n"));
        }
      }
      if (node.type === "if") {
        console.log(string, "if", node.content);
        printMiddleCode(node.body, indent + 1);
        if (node.elseIfList && node.elseIfList.length > 0) {
          _ref2 = node.elseIfList;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            item = _ref2[_l];
            console.log(string, "elseif", item.content);
            printMiddleCode(item.body, indent + 1);
          }
        }
        if (node.elseNode) {
          console.log(string, "else");
          printMiddleCode(node.elseNode.body, indent + 1);
        }
        _results.push(console.log(string, "end-if"));
      } else if (node.type === "each") {
        console.log(string, "each", node.content);
        printMiddleCode(node.body, indent + 1);
        _results.push(console.log(string, "end-each"));
      } else if (node.type === "def") {
        console.log(string, "def", node.content);
        _results.push(printMiddleCode(node.body, indent + 1));
      } else if (node.type === "call-expand") {
        console.log(string, "call-expand->");
        printMiddleCode(node.body, indent + 1);
        _results.push(console.log(string, "/end call"));
      } else {
        _results.push(console.log(string, node.type, node.content));
      }
    }
    return _results;
  };

  exports.link = function(heads, tails, code) {
    var head, tail, _i, _j, _len, _len1;
    for (_i = 0, _len = heads.length; _i < _len; _i++) {
      head = heads[_i];
      codes.push(fs.readFileSync(head).toString());
    }
    codes.push(code);
    for (_j = 0, _len1 = tails.length; _j < _len1; _j++) {
      tail = tails[_j];
      codes.push(fs.readFileSync(tail).toString());
    }
    return codes.join("\n");
  };

  exports.printMiddleCode = printMiddleCode;

}).call(this);
